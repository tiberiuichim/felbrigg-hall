go.property("character_name", hash("Dalia"))

KEY_UP = hash("key_up")
KEY_DOWN = hash("key_down")
KEY_RIGHT = hash("key_right")
KEY_LEFT = hash("key_left")
SPEED = 100

local camera = require "orthographic.camera"

local CAMERA_ID = hash("/orthocamera")

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	msg.post(".", "acquire_input_focus")

	self.dir = vmath.vector3()
	self.current_animation = nil

	self.stop_animation = hash("idle_front")

	-- local textnode = gui.get_node("label")
	-- gui.set_text(textnode, self.character_name)
end

function animate_character(self) 
	-- setup animations
	local anim = self.stop_animation

	if self.dir.x > 0 then
		anim = hash("walk_right")
		self.stop_animation = hash("idle_right")
	elseif self.dir.x < 0 then
		anim = hash("walk_left")
		self.stop_animation = hash("idle_left")
	elseif self.dir.y > 0 then
		anim = hash("walk_back")
		self.stop_animation = hash("idle_back")
	elseif self.dir.y < 0 then
		anim = hash("walk_front")
		self.stop_animation = hash("idle_front")
	end

	if anim ~= self.current_animation then
		msg.post("#sprite", "play_animation", { id = anim })
		-- msg.post("#player_sprite", "play_animation", { id = self.last_animation})
		self.current_animation = anim
	end
end

-- function character_collides_with_obstacle(position)
-- 	-- Check for collisions with the obstacle group
-- 	local result = physics.raycast(position, position + vmath.vector3(0, 0, 0), {group = hash("obstacle")})
-- 	return result and result.group == hash("obstacle")
-- end

function update(self, dt)
	-- this makes sure to normalize the vector, but I don't this it's needed
	-- if vmath.length_sqr(self.dir) > 1 then
	-- 	self.dir = vmath.normalize(self.dir)
	-- end
	
	local p = go.get_position()

	-- move the character to new position
	-- Check for collisions with obstacles
-- 	local collision_response = vmath.vector3(0, 0, 0) -- Initialize response vector
-- 
-- 	if character_collides_with_obstacle(pos) then
-- 		-- Handle collision, for example, stop movement
-- 		collision_response = vmath.vector3(0, 0, 0)
-- 	end
	
	go.set_position(p + self.dir * SPEED * dt)

	animate_character(self)

	-- stop moving
	self.dir = vmath.vector3()

	-- draw the name text
	-- msg.post("@render:", "draw_text", { text = "Hello", position = vmath.vector3(10, 20, 0) } )
end

function on_input(self, action_id, action)
	local action_pos = vmath.vector3(action.x, action.y, 0)
	local action_world_pos = camera.screen_to_world(CAMERA_ID, action_pos)
	local camera_pos = go.get_position(CAMERA_ID)
	local zoom = camera.get_zoom(CAMERA_ID)

	-- go.set_position(action_world_pos, "zoomer")

	if action_id == KEY_UP then
		self.dir.y = 1                            -- [15]
	elseif action_id == KEY_DOWN then
		self.dir.y = -1
	elseif action_id == KEY_LEFT then
		self.dir.x = -1
	elseif action_id == KEY_RIGHT then
		self.dir.x = 1
	elseif action_id == hash("action") then
		msg.post("/orthocamera", camera.MSG_SHAKE, {}, function () 
			print("We shook the camera")
		end)
	elseif action_id == hash("zoom_in") then
		zoom = math.min(4, zoom + 0.05)
		camera.set_zoom(CAMERA_ID, zoom)
	elseif action_id == hash("zoom_out") then
		zoom = math.max(0.2, zoom - 0.05)
		camera.set_zoom(CAMERA_ID, zoom)
	end

end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		print('m.group', message.group)
		print('m.normal', message.normal)
		print('m.distance', message.distance)
		print('position', go.get_position())


		-- DEBUG:SCRIPT: m.group	hash: [objects]
		-- DEBUG:SCRIPT: m.normal	vmath.vector3(1, 0, 0)
		-- DEBUG:SCRIPT: m.distance	-1.5247106552124
		-- DEBUG:SCRIPT: position	vmath.vector3(-76.475379943848, -58.996097564697, 1)
		
		-- go.set_position(go.get_position() + message.normal * message.distance)
	end
	
	-- print("message", message_id)
	-- 
	-- if message_id == hash("trigger_response") then
	-- 	if message.enter then
	-- 		-- Character entered a trigger
	-- 		if message.other_group == hash("terrain_object_collisions") then
	-- 			-- Handle collision with trees (e.g., stop movement)
	-- 			print("Collided with a tree!")
	-- 		end
	-- 	elseif message.exit then
	-- 		-- Character exited a trigger
	-- 	end
	-- end
end