go.property("speed", 100)
go.property(camera, hash("/orthocamera"))

KEY_UP = hash("key_up")
KEY_DOWN = hash("key_down")
KEY_RIGHT = hash("key_right")
KEY_LEFT = hash("key_left")

local camera = require "orthographic.camera"

function init(self)
	msg.post(".", "acquire_input_focus")

	self.input = vmath.vector3()
	
	self.current_animation = nil
	self.stop_animation = hash("idle_front")
end

function animate_character(self) 
	local anim = self.stop_animation

	if self.input.x > 0 then
		anim = hash("walk_right")
		self.stop_animation = hash("idle_right")
	elseif self.input.x < 0 then
		anim = hash("walk_left")
		self.stop_animation = hash("idle_left")
	elseif self.input.y > 0 then
		anim = hash("walk_back")
		self.stop_animation = hash("idle_back")
	elseif self.input.y < 0 then
		anim = hash("walk_front")
		self.stop_animation = hash("idle_front")
	end

	if anim ~= self.current_animation then
		msg.post("#sprite", "play_animation", { id = anim })
		self.current_animation = anim
	end
end

local function handle_geometry_contact(self, normal, distance)
	-- project the correction vector onto the contact normal
	-- (the correction vector is the 0-vector for the first contact point)
	local proj = vmath.dot(self.correction, normal)
	-- calculate the compensation we need to make for this contact point
	local comp = (distance - proj) * normal
	-- add it to the correction vector
	self.correction = self.correction + comp
	-- apply the compensation to the player character
	go.set_position(go.get_position() + comp)
	-- check if the normal points enough up to consider the player standing on the ground
	-- (0.7 is roughly equal to 45 degrees deviation from pure vertical direction)
	-- if normal.y > 0.7 then
	-- 	self.is_touching_obstacles = true
	-- end
	-- -- project the velocity onto the normal
	-- proj = vmath.dot(self.velocity, normal)
	-- -- if the projection is negative, it means that some of the velocity points towards the contact point
	-- if proj < 0 then
	-- 	-- remove that component in that case
	-- 	self.velocity = self.velocity - proj * normal
	-- end
end

function update(self, dt)
	if vmath.length_sqr(self.input) > 1 then   -- takes care of diagonal movement, see https://github.com/defold/tutorial-movement
		self.input = vmath.normalize(self.input)
	end
	
	local p = go.get_position()
	go.set_position(p + self.input * self.speed * dt)
	animate_character(self)

	self.input = vmath.vector3()    -- reset the input, stop moving

	-- reset volatile state
	self.correction = vmath.vector3()
	self.is_touching_obstacles = false
end

function on_input(self, action_id, action)
	local action_pos = vmath.vector3(action.x, action.y, 0)
	local action_world_pos = camera.screen_to_world(self.camera, action_pos)
	local camera_pos = go.get_position(self.camera)
	local zoom = camera.get_zoom(self.camera)

	if action_id == KEY_UP then
		self.input.y = 1
	elseif action_id == KEY_DOWN then
		self.input.y = -1
	elseif action_id == KEY_LEFT then
		self.input.x = -1
	elseif action_id == KEY_RIGHT then
		self.input.x = 1
	elseif action_id == hash("action") then
		msg.post("/orthocamera", camera.MSG_SHAKE, {}, function () 
			print("We shook the camera")
		end)
	elseif action_id == hash("zoom_in") then
		zoom = math.min(4, zoom + 0.05)
		camera.set_zoom(self.camera, zoom)
	elseif action_id == hash("zoom_out") then
		zoom = math.max(0.2, zoom - 0.05)
		camera.set_zoom(self.camera, zoom)
	end

end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		handle_geometry_contact(self, message.normal, message.distance)
		-- print('m.group', message.group)
		-- print('m.normal', message.normal)
		-- print('m.distance', message.distance)
		-- print('position', go.get_position())

		-- DEBUG:SCRIPT: m.group	hash: [objects]
		-- DEBUG:SCRIPT: m.normal	vmath.vector3(1, 0, 0)
		-- DEBUG:SCRIPT: m.distance	-1.5247106552124
		-- DEBUG:SCRIPT: position	vmath.vector3(-76.475379943848, -58.996097564697, 1)
		
		-- go.set_position(go.get_position() + message.normal * message.distance)
	end
end