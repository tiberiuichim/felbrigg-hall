go.property("speed", 100)
go.property(camera, hash("/orthocamera"))

KEY_UP = hash("key_up")
KEY_DOWN = hash("key_down")
KEY_RIGHT = hash("key_right")
KEY_LEFT = hash("key_left")
KEY_ACTION = hash("action")

WALK_LEFT = hash("walk_left")
WALK_RIGHT = hash("walk_right")
WALK_BACK = hash("walk_back")
WALK_FRONT = hash("walk_front")
IDLE_RIGHT = hash("idle_right")
IDLE_LEFT = hash("idle_left")
IDLE_BACK = hash("idle_back")
IDLE_FRONT = hash("idle_front")

ZOOM_IN = hash("zoom_in")
ZOOM_OUT = hash("zoom_out")

ZOOM_OUT_MAX = 0.5
ZOOM_IN_MAX = 2

local camera = require "orthographic.camera"

function init(self)
	msg.post(".", "acquire_input_focus")

	self.input = vmath.vector3()
	
	self.current_animation = nil
	self.stop_animation = hash("idle_front")
end

function animate_character(self) 
	local anim = self.stop_animation

	if self.input.x > 0 then
		anim = WALK_RIGHT
		self.stop_animation = IDLE_RIGHT
	elseif self.input.x < 0 then
		anim = WALK_LEFT
		self.stop_animation = IDLE_LEFT
	elseif self.input.y > 0 then
		anim = WALK_BACK
		self.stop_animation = IDLE_BACK
	elseif self.input.y < 0 then
		anim = WALK_FRONT
		self.stop_animation = IDLE_FRONT
	end

	if anim ~= self.current_animation then
		msg.post("#sprite", "play_animation", { id = anim })
		self.current_animation = anim
	end
end

function handle_geometry_contact(self, normal, distance)
	-- project the correction vector onto the contact normal
	-- (the correction vector is the 0-vector for the first contact point)
	local proj = vmath.dot(self.correction, normal)
	-- calculate the compensation we need to make for this contact point
	local comp = (distance - proj) * normal
	-- add it to the correction vector
	self.correction = self.correction + comp
	-- apply the compensation to the player character
	go.set_position(go.get_position() + comp)
	
	-- check if the normal points enough up to consider the player standing on the ground
	-- (0.7 is roughly equal to 45 degrees deviation from pure vertical direction)
	-- if normal.y > 0.7 then
	-- 	self.is_touching_obstacles = true
	-- end
	-- -- project the velocity onto the normal
	-- proj = vmath.dot(self.velocity, normal)
	-- -- if the projection is negative, it means that some of the velocity points towards the contact point
	-- if proj < 0 then
	-- 	-- remove that component in that case
	-- 	self.velocity = self.velocity - proj * normal
	-- end
end

function update(self, dt)
	if vmath.length_sqr(self.input) > 1 then   -- takes care of diagonal movement, see https://github.com/defold/tutorial-movement
		self.input = vmath.normalize(self.input)
	end
	
	local p = go.get_position()
	go.set_position(p + self.input * self.speed * dt)
	animate_character(self)

	self.input = vmath.vector3()    -- reset the input, stop moving

	-- reset volatile state
	self.correction = vmath.vector3()
	self.is_touching_obstacles = false
end

function on_input(self, action_id, action)
	local action_pos = vmath.vector3(action.x, action.y, 0)
	local action_world_pos = camera.screen_to_world(self.camera, action_pos)
	local camera_pos = go.get_position(self.camera)

	if action_id == KEY_UP then
		self.input.y = 1
	elseif action_id == KEY_DOWN then
		self.input.y = -1
	elseif action_id == KEY_LEFT then
		self.input.x = -1
	elseif action_id == KEY_RIGHT then
		self.input.x = 1
	elseif action_id == KEY_ACTION then
		shake_camera()
	elseif action_id == ZOOM_IN then
		zoom_in(self)
	elseif action_id == ZOOM_OUT then
		zoom_out(self)
	end

end
	
function zoom_out(self)
	local zoom = camera.get_zoom(self.camera)
	zoom = math.max(ZOOM_OUT_MAX, zoom - 0.05)
	camera.set_zoom(self.camera, zoom)
end

function zoom_in(self) 
	local zoom = camera.get_zoom(self.camera)
	zoom = math.min(ZOOM_IN_MAX, zoom + 0.05)
	camera.set_zoom(self.camera, zoom)
end

function shake_camera()
	msg.post("/orthocamera", camera.MSG_SHAKE, {}, function () 
		print("We shook the camera")
	end)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		handle_geometry_contact(self, message.normal, message.distance)
	end
end